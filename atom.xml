<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Development Blog]]></title>
  <link href="http://akiellor.github.io/atom.xml" rel="self"/>
  <link href="http://akiellor.github.io/"/>
  <updated>2013-07-29T01:33:16-07:00</updated>
  <id>http://akiellor.github.io/</id>
  <author>
    <name><![CDATA[Andrew Kiellor]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build an Interative Prompt for your Java application.]]></title>
    <link href="http://akiellor.github.io/blog/2013/07/28/pry-jruby/"/>
    <updated>2013-07-28T23:58:00-07:00</updated>
    <id>http://akiellor.github.io/blog/2013/07/28/pry-jruby</id>
    <content type="html"><![CDATA[<h2>Tools</h2>

<p><a href="http://maven.apache.org">Maven</a> will be used to build this application, but
the approach can be ported to <a href="http://gradle.org">Gradle</a> trivially.</p>

<p><a href="http://pryrepl.org/">Pry</a> is an awesome RubyGem which gives a bit more polished IRB.</p>

<p><a href="http://jruby.org">JRuby</a> allows you to use Pry as an interactive prompt for
your java application.</p>

<h2>The Code</h2>

<p>For this exercise we will be using <a href="http://maven.apache.org">Maven</a> to build
our application.</p>

<p>Maven uses a pom.xml file to declare dependencies and additional build logic.
Start with a basic pom.xml.</p>

<script src="https://gist.github.com/akiellor/6102781.js?file=pom-empty.xml"></script>


<p>Next some dependencies. It important to add the additional &lsquo;gemjars&rsquo; repository.
The &lsquo;gemjars&rsquo; repository is a mirror of RubyGems, but is structured in a way that is suitable for use with Maven.</p>

<script src="https://gist.github.com/akiellor/6102781.js?file=pom-dependencies.xml"></script>


<p>We&rsquo;ll add configuration for the Maven java compiler and the maven-shade-plugin.
The compiler configuration is provided to tell Maven to compile for version 1.6
of java. The maven-shade-plugin is a way of packaging a java application into a
&lsquo;fatjar&rsquo;.</p>

<script src="https://gist.github.com/akiellor/6102781.js?file=pom-plugins.xml"></script>


<p>A regular java main-class (<strong><em>src/main/java/com/example/pry/Main.java</em></strong>) is used
to start JRuby and Pry.</p>

<script src="https://gist.github.com/akiellor/6102781.js?file=Main.java"></script>


<h2>Build</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ mvn clean package</span></code></pre></td></tr></table></div></figure>


<h2>Run It</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ java -jar target/pry-0.0.1-SNAPSHOT-shaded.jar</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Architectural Cost: A year of Gemjars.]]></title>
    <link href="http://akiellor.github.io/blog/2013/05/21/architectural-cost-a-year-of-gemjars/"/>
    <updated>2013-05-21T09:15:00-07:00</updated>
    <id>http://akiellor.github.io/blog/2013/05/21/architectural-cost-a-year-of-gemjars</id>
    <content type="html"><![CDATA[<p>This post is an experience report of building, maintaining and rebuilding a internet service, <a href="http://gemjars.org">Gemjars</a>. It shows how the usage bills from Infrastructure Providers can be motivation for architectural cost reduction and improvement.</p>

<h2>What is Gemjars?</h2>

<p><a href="http://gemjars.org">Gemjars</a> is a service I have been running for the last year. It allows you to include RubyGems as dependencies in any maven-based dependency management tool<a href="#conclusion">[1]</a> for use with JRuby. It does this by bridging the HTTP API for maven to the HTTP API for RubyGems. For hybrid java/ruby projects this is means the build tooling is uniform for either the ruby or java code. <strong>WIN!</strong></p>

<h2>Caching Proxy Architecture</h2>

<p>The original architecture of Gemjars.org used a caching proxy-based architecture. When Gemjars didn&rsquo;t have a requested resource in the cache, it would</p>

<ul>
<li>Fetch the gem from RubyGems</li>
<li>Package it as a jar with its associated pom.xml</li>
<li>Cache any generated artifacts (pom, jar, ivy.xml)</li>
<li>Send them back to the client.</li>
</ul>


<p>This approach was sound and validated the idea, but there were some significant deficiencies:</p>

<ul>
<li>Native extensions could not be repackaged for consumers because they are not supported by JRuby.</li>
<li>Requests often take a long time, because of the in-request interaction with RubyGems and this caused request timeouts for some consumers (especially intermediate proxies like artifactory).</li>
<li>The were some reasonably serious stability issues also, where the only known solution was to restart the service. I have theories about thread safety issues when using the RubyGems API in a multithreaded environment, but there was nothing I could really put my finger on.</li>
</ul>


<p>The worst thing about all of these issues is that they stopped developers from continuing with their work. <strong>FAIL!</strong></p>

<h2>Rethinking the Design</h2>

<p>For a long time I had thought about enhancing the design by caching the artifacts in an S3 bucket and redirect the client there. This would have meant that all clients would have to follow redirects, which I couldn&rsquo;t guarantee. But it led me to the thought of using an S3 bucket as a mirror for all RubyGems.</p>

<p>Initially I thought this was a crazy idea, RubyGems is huge. But using the <a href="http://calculator.s3.amazonaws.com/calc5.html">AWS Calculator</a> I was able to quickly see whether this was financially viable. The numbers:</p>

<ul>
<li><strong>Storage:</strong> ~100GB (built a straight RubyGems mirror to get this number)</li>
<li><strong>GET Requests:</strong> 1m (current traffic is about 150k, most HEAD requests)</li>
<li><strong>PUT Requests:</strong> 300k (Guess)</li>
<li><strong>Data Out:</strong> 20GB (Guess)</li>
<li><strong>Data In:</strong> ~100GB (Represents a full mirror, ongoing would be smaller)</li>
</ul>


<p><strong>Total Cost: $11.52 USD</strong></p>

<p>The amazing thing is that I was already spending about $40 on a small EC2 instance. With these estimates, the design seemed cost effective. Apparently RubyGems is not that huge.</p>

<p>The static design served from S3 seemed like a good way to solving the stability. The S3 SLA states that if they do not provide 99.9% uptime I will be reimbursed with service credit, there is no way I could provide that level of service on my own.</p>

<p>The request timeout issues became a non-issue as all the artifacts were built ahead of time, removing the latency to RubyGems. A nice side effect of the design is that as all gems are processed ahead of time, allowing for a compatibility page. A compatibility page should help greatly when diagnosing why a gem is unavailable.</p>

<h2>Conclusion</h2>

<p><span id="conclusion">Quantifying</span> the cost of infrastructure is extremely valuable. Without measuring the cost of infrastructure it is impossible to decrease the cost in an informed way. Part of the value proposition of AWS and other infrastructure service providers is that your infrastructure cost is quantified in your monthly bill.</p>

<p>S3 has changed my default design for a public facing website. Typically I would have used some ruby server, sinatra, and haml. The ruby stack comes with two basic options for deployment: Heroku or Roll-Your-Own. Heroku is good to start, free, slow if your dyno stops, and faster if you pay. Roll your own is expensive to start, many tools make it easier, but you still have to at least think about, OS, instance size, chef/puppet, packaging, deployment&hellip; and the list goes on. There is a lot of knowledge required to do this well, and is an expensive way of serving HTML.</p>

<p>Now when looking at a web problem, Iâ€™ll be looking to see how I can build it with a cheap, reliable, static solution.</p>

<p>[1] for example: Maven, Ivy, Gradle, Buildr, leiningen</p>
]]></content>
  </entry>
  
</feed>
